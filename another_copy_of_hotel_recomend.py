# -*- coding: utf-8 -*-
"""Another copy of hotel_recomend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1llzt6JsT6hc2tyaDL_siopwYiouMHLYg
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel
from scipy.sparse import hstack

df=pd.read_excel('/content/drive/MyDrive/Resturant_Data/Resturant_data_1000.xlsx')

df.head()

df.shape

import pandas as pd

# Remove leading and trailing spaces from the 'Opening Hours' column
df['Opening Hours'] = df['Opening Hours'].str.strip()

# Remove any additional unconverted data, such as '- 12:00 AM'
df['Opening Hours'] = df['Opening Hours'].str.replace('-.*', '', regex=True)

# Convert to datetime format
df['Opening Hours'] = pd.to_datetime(df['Opening Hours'], format='%I:%M', errors='coerce')

df.info()

# @title City vs Rating
figsize = (12, 1.2 * len(df['City'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(df, x='Rating', y='City', inner='stick', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

df.groupby('City').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)

import matplotlib.pyplot as plt

# Check the data type of the 'Rating' column
if df['Rating'].dtype != 'float64' and df['Rating'].dtype != 'int64':
    # Convert the 'Rating' column to a numeric type
    df['Rating'] = pd.to_numeric(df['Rating'], errors='coerce')

# Plot the histogram if the data type is numeric
if df['Rating'].dtype == 'float64' or df['Rating'].dtype == 'int64':
    df['Rating'].plot(kind='hist', bins=20, title='Rating')
    plt.gca().spines[['top', 'right']].set_visible(False)
    plt.show()
else:
    print("The 'Rating' column does not contain numeric data.")

"""---
# Resturant Recomendation
---

# New Section
"""

# vectorizer for cuisine
cuisine_tfidf = TfidfVectorizer()
cuisine_feature = cuisine_tfidf.fit_transform(df['Cuisine'])

# vectorizer for location
location_tfidf = TfidfVectorizer()
location_feature = location_tfidf.fit_transform(df['Location'])

# Combine the feature vectors
combined_features = hstack([cuisine_feature, location_feature])

# Compute the cosine similarity matrix
cosine_similarities = linear_kernel(combined_features, combined_features)

# Function to get restaurant recommendations based on a given restaurant name
def get_recommendations(name, cosine_similarities, df, top_n=5):
    # Get the index of the restaurant
    idx = df[df['Name'] == name].index[0]

    # Get the pairwise similarities of the restaurant with other restaurants
    sim_scores = list(enumerate(cosine_similarities[idx]))

    # Sort the restaurants based on similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the top N similar restaurants (excluding the input restaurant itself)
    top_similar_restaurants = [sim_scores[i][0] for i in range(1, top_n + 1)]

    # Return the recommended restaurant names
    return df['Name'].iloc[top_similar_restaurants]

def get_recommendations(restaurant_name, cosine_similarities, df):
    # Get the index of the restaurant with the given name
    restaurant_index = df[df['Restaurant Name'] == restaurant_name].index[0]

    # Get the similarity scores for the restaurant
    similarity_scores = list(enumerate(cosine_similarities[restaurant_index]))

    # Sort the restaurants based on similarity scores in descending order
    sorted_scores = sorted(similarity_scores, key=lambda x: x[1], reverse=True)

    # Get the indices of the top 5 similar restaurants
    top_indices = [i[0] for i in sorted_scores[1:6]]  # Exclude the first index (self-match)

    # Get the names of the top 5 similar restaurants
    recommendations = df.loc[top_indices, 'Restaurant Name']

    return recommendations

# Call the get_recommendations() function
restaurant_name = 'The Kebab House'
recommendations = get_recommendations(restaurant_name, cosine_similarities, df)

# Print the recommendations
print(f"Recommendations for {restaurant_name}:")
print(recommendations)

import pickle

# Assuming you have trained and evaluated your model
model = 'recommendations'  # Your trained model object

# Save the model to disk using pickle
with open('recommended_model.pkl', 'wb') as f:
    pickle.dump(model, f)

!pip install streamlit -q

!wget -q -O - ipv4.icanhazip.com

! streamlit run  app.py & npx localtunnel --port 8501

import joblib
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression

# Assuming you have created the cuisine_tfidf vectorizer and a classifier
cuisine_tfidf = TfidfVectorizer()
classifier = LogisticRegression()

# Fit the vectorizer and classifier to your data

# Save the complete model
joblib.dump((cuisine_tfidf, classifier), 'complete_model.pkl')